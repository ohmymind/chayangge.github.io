<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>插秧哥&#39;s Blog</title>
  
  <subtitle>Never Stop Learning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chayangge.com/"/>
  <updated>2020-09-16T17:17:13.740Z</updated>
  <id>http://chayangge.com/</id>
  
  <author>
    <name>插秧哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SSE</title>
    <link href="http://chayangge.com/2020/09/17/SSE/"/>
    <id>http://chayangge.com/2020/09/17/SSE/</id>
    <published>2020-09-16T17:17:13.000Z</published>
    <updated>2020-09-16T17:17:13.740Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP协议变迁</title>
    <link href="http://chayangge.com/2019/05/09/http%E5%8D%8F%E8%AE%AE%E5%8F%98%E8%BF%81/"/>
    <id>http://chayangge.com/2019/05/09/http协议变迁/</id>
    <published>2019-05-09T03:36:42.000Z</published>
    <updated>2021-03-21T07:38:30.015Z</updated>
    
    <content type="html"><![CDATA[<p>http协议是一个不大不小的知识体系，当新手还没有整体视角的时候，只会记忆某一版本的某一特性，以为搞懂了一个知识点但随后又发现一个更大的盲区。当抛弃这些繁杂知识点，以解决互联网传输问题为导向，才能更好的理解http的变迁，毕竟http和软件开发有诸多类似，都是一个根据发展现状不算迭代补漏的过程，毕竟设计者也没有预支未来的能力，而这些迭代主要在以下方面：</p><ul><li>丰富传输内容：最开始并不支持图片视频类的多媒体文件</li><li>减少来回传输次数：减少RTT（Round Trip Time）即消息一来一回所花费的时间</li><li>一次传输尽可能传输更多：压缩</li><li>尽可能多路复用</li><li>加密</li><li>缓存：减少不必要的传输</li></ul><p>###先看时间线<br>1991年：http0.9 那个年代的互联网有多简陋可想而知，仅支持get<br>1996年：http1.0 不够用了，添加请求方法POST用于提交，文件类型，如图片视频，添加请求头http Header<br>1997年：http1.1 目前用的都是1.1，居然诞生于二十多年前<br>2009年：SPDY1 （http2前身）<br>2012年：SPDY2 （http2前身）<br>2015年：http2</p><h3 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h3><p>1997年的http1.1引入和很多实用机制：</p><ul><li>持久连接： 减少了RTT，不必每次都重新建立tcp链接，重复三次握手</li><li>分块传输编码 </li><li>缓存控制机制：减少没必要的传输</li><li>内容协商机制：给请求头中客户端所期望的内容，如json，text等</li><li>管道机制：尴尬</li></ul><p>持久连接依然有性能问题：http1中每个请求和响应都有建立一个tcp连接，虽然1.1引用了持久连接机制，但每个连接上同时只能有一个请求或响应，这样，一来，一回完成后，再继续下一个一来一回，处于半双工状态利用率不高。因为服务器发送第一个响应后，到手打第二个请求之前，都是空闲状态。<br>为了解决此问题，引入了管道。</p><p>尴尬的管道机制：管道可以让浏览器把所有请求都发过来，服务器则可以响应一个后继续响应下一个，但有个严重的问题：当第一个非常耗时阻塞时，后续所有响应都要等待，这就是队首阻塞问题（Head-of-Line Blocking）。<br>第二个主要尴尬原因：链路中间的其他设备不一定支持管道，这些导致管道一直处于理论状态，实际应用很少。</p><p>题外话：现代浏览器允许统一域名下并发连接6-8个tcp连接，为此很多网页静态资源放在散列的多个域名下。</p><p>还有请求头是未压缩的纯文本，且有很多冗余信息，如cookie、UserAgent等，造成不必要的浪费，优化方法是采用短小的独立域名托管静态资源：1.域名段，字段少，2.独立域名不共享cookie减少无用内容。</p><h3 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h3><ul><li><p>格式化传输数据：<br>http1.1中请求和响应报文，由起始行、首部和实体正文组成，中间由文本换行符分割，http2把报文分割成更小的帧，并进行二进制编码，帧（Frame）作为http2通信的最小单位。帧都包含帧首部用来进行流标识，这样帧可以乱序发送，最后靠首部的流标识进行顺序组装。</p></li><li><p>多路复用<br>http2中，同域名下的所有通信都在一个tcp连接上完成，且连接是双向通信数据流，这正是tcp协议的长项：三次握手后，持续发送大量数据。<br>重点：之前http之所以性能差，是因为频繁建立多个tcp，虽然基于tcp，但因为一次连接传输内容少，而连接频发，导致tcp的优势利于的少，劣势利用的多;</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;http协议是一个不大不小的知识体系，当新手还没有整体视角的时候，只会记忆某一版本的某一特性，以为搞懂了一个知识点但随后又发现一个更大的盲区。当抛弃这些繁杂知识点，以解决互联网传输问题为导向，才能更好的理解http的变迁，毕竟http和软件开发有诸多类似，都是一个根据发展现
      
    
    </summary>
    
    
      <category term="http" scheme="http://chayangge.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>instanceof</title>
    <link href="http://chayangge.com/2019/04/28/instanceof/"/>
    <id>http://chayangge.com/2019/04/28/instanceof/</id>
    <published>2019-04-28T08:42:47.000Z</published>
    <updated>2019-04-28T09:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>instanceof用来判断对象是否属于某种类型，比如：判断一个示例是否是某个对象的实现，也就是改示例是否属于该对象类型。</p><p>其原理呢，用另一个定义即可说明：instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置。</p><p>由此可得：一个对象instanceof于各个层级的<strong>proto</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    this.method1 = function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.method2 = function()&#123;&#125;</span><br><span class="line"> </span><br><span class="line">function Man()&#123;</span><br><span class="line">    this.name = &apos;tom&apos;;</span><br><span class="line">&#125;</span><br><span class="line">Man.prototype = new Person();</span><br><span class="line"> </span><br><span class="line">Man.prototype.m1 = function()&#123;&#125;</span><br><span class="line">Man.prototype.m2 = function()&#123;&#125;</span><br><span class="line"> </span><br><span class="line">var m = new Man();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(&apos;instace&apos;,m instanceof Man); // true</span><br><span class="line">console.log(&apos;instace&apos;,m instanceof Person); // true</span><br><span class="line">console.log(&apos;instace&apos;,m instanceof Object); // true</span><br><span class="line"></span><br><span class="line">// 还有以下都为true</span><br><span class="line">console.log(&apos;Person instanceof Function:&apos;,Person instanceof Function);</span><br><span class="line">console.log(&apos;Person instanceof Object:&apos;,Person instanceof Object);</span><br><span class="line">console.log(&apos;Function instanceof Object:&apos;,Function instanceof Object);</span><br></pre></td></tr></table></figure><p>下面是递归实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function _instanceof(left,right)&#123;</span><br><span class="line">    if(left === null)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    let leftProto = left.__proto__;</span><br><span class="line">    let rightProto = right.prototype;</span><br><span class="line"></span><br><span class="line">    if(leftProto === rightProto)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;222&apos;);</span><br><span class="line">    return _instanceof(leftProto,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(_instanceof(m,Man));</span><br><span class="line">console.log(_instanceof(m,Person));</span><br><span class="line">console.log(_instanceof(m,Object));</span><br><span class="line">console.log(_instanceof(Person,Function));</span><br><span class="line">console.log(_instanceof(Function,Object));</span><br></pre></td></tr></table></figure><p>实现2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function _instanceof(leftVaule, rightVaule) &#123; </span><br><span class="line">    let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值</span><br><span class="line">    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值</span><br><span class="line">    while (true) &#123;</span><br><span class="line">    if (leftVaule === null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (leftVaule === rightProto) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; </span><br><span class="line">        leftVaule = leftVaule.__proto__ </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题外话：有些属性在对象上，有些属性在对象的原型链上，有些属性在原型链的原型链上，有且仅有hasOwnProperty能够判断是否直接在对象属性上，因此for in遍历对象时要按需选择是否要判断hasOwnProperty。</p><p>当对象的一个属性是在其原型链上时，hasOwnProperty肯定为false，但取其原型链再hasOwnProperty则为true，以此类推后续原型链。</p><p>此外：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.__proto__ === Man.prototype === Object.getPrototypeOf(m)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;instanceof用来判断对象是否属于某种类型，比如：判断一个示例是否是某个对象的实现，也就是改示例是否属于该对象类型。&lt;/p&gt;
&lt;p&gt;其原理呢，用另一个定义即可说明：instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置。&lt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>对称加密与非对称加密</title>
    <link href="http://chayangge.com/2019/04/25/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    <id>http://chayangge.com/2019/04/25/对称加密与非对称加密/</id>
    <published>2019-04-25T09:28:09.000Z</published>
    <updated>2019-04-26T02:03:22.199Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>A和B通信，为了保密，两人商定好，用每个字符向前推一位的加密方式传输，那么消息hello则被加密为ifmmp，B知道这个加密规则，收到后字母退一位，则解析出hello，这就是对称加密。</p><p>缺点也很明显：</p><ul><li>事先需要约定加密规则（秘钥），一旦被盗取，密文相当于明文</li><li>但凡知道秘钥，给所有人的消息都统一破解了，影响整体</li></ul><h3 id="非对称加密算法RSA"><a href="#非对称加密算法RSA" class="headerlink" title="非对称加密算法RSA"></a>非对称加密算法RSA</h3><p>非对称加密解决了上述两个问题。</p><ul><li>传消息之前先告知各自的公钥，然后用各自的私钥解密消息，公钥被盗取了也不怕</li><li>哪怕破解了，也仅是一对一，不用影响别人</li></ul><p>所以用非对称加密的传出方式是：</p><ul><li>1.因为公钥是公开的，任何人都能获取，所以通信前，先互换公钥</li><li>2.信息用对方的公钥加密</li><li>3.对方收到后，用自己私藏的私钥解密，也仅有私钥能（迅速）解密出信息</li></ul><p>至于其中的算法，参考：<br><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a></p><p>如果没有私钥，也是能暴力破解的，时间以目前的计算机能力，花个几百上千年，收益明显小于成本，时间没有打不开的锁，打开成本很大的锁，我们就可以认为是安全的锁。</p><p>现在只有一个问题：<br>如果有C在最开始伪装成B，把自己的公钥发给A了，这个最初环节的冒充该怎么办？</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>我们需要引入一个东西，来弥补目前的漏洞：证明你发出的公钥是你的。</p><p>怎么证明呢？引入一个第三方的信得过的机构来着认证。当然这个第三方公证处也有自己的公钥和私钥。首先，第三方公证处拿要认证的公钥和公钥归属人信息用自己的【私钥】加密，密文写在了证书上。注意：公证处的公钥也是公开的。</p><p>当通信时，对方不仅提供自己的公钥，还要提供公钥的证书，接收方收到后，用公证处的公钥解密证书上的密文，判断解密出公钥和一起收到的公钥是否一致，一致则说明可靠。（密文是公证处私钥加密的，所以之能用公证处的公钥解开）</p><p>公证处的公钥就是【根证书】，我们的电脑上已经预装了。</p><h3 id="如何使用证书"><a href="#如何使用证书" class="headerlink" title="如何使用证书"></a>如何使用证书</h3><p>先拿个人信息去公证处申请，把成功后得到的证书，放在自己的服务器上，公证处的公钥【根证书】已经预装在电脑本地了，所以服务器向浏览器通信时，向浏览器发出自己公钥和证书，浏览器拿根证书解密证书上的密文，发现与收到公钥一样，判断为信任，从而建立起https加密链接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对称加密&quot;&gt;&lt;a href=&quot;#对称加密&quot; class=&quot;headerlink&quot; title=&quot;对称加密&quot;&gt;&lt;/a&gt;对称加密&lt;/h3&gt;&lt;p&gt;A和B通信，为了保密，两人商定好，用每个字符向前推一位的加密方式传输，那么消息hello则被加密为ifmmp，B知道这个加密
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于CAS的SSO基本实现流程</title>
    <link href="http://chayangge.com/2019/04/23/%E5%9F%BA%E4%BA%8ECAS%E7%9A%84SSO%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/"/>
    <id>http://chayangge.com/2019/04/23/基于CAS的SSO基本实现流程/</id>
    <published>2019-04-23T14:16:11.000Z</published>
    <updated>2019-04-23T15:57:29.683Z</updated>
    
    <content type="html"><![CDATA[<p>CAS:中央认证服务（Central Authentication Service）。<br>SSO：单点登录（Single Sign On）。</p><p>当一个账号能需要登录多个系统时，比如用新浪微博登录新浪官网、邮箱等，是不需要反复输入账号密码登录的，其背后的实现机制就是SSO。</p><p>中央认证服务是SSO常见的实现方式，抽一个服务专门负责登录，并向各个子系统提供登录认证。</p><h3 id="1-未登录用户首次访问目标系统"><a href="#1-未登录用户首次访问目标系统" class="headerlink" title="1.未登录用户首次访问目标系统"></a>1.未登录用户首次访问目标系统</h3><p>此时cookie非常干净，目标系统没检索到任何登录信息，视为未登录状态，重定向到中央登录系统，重定向URL参数带上目标系统的信息，如系统id（后续使用）、地链接址（用于登陆后回调）。</p><h3 id="2-用户登录"><a href="#2-用户登录" class="headerlink" title="2.用户登录"></a>2.用户登录</h3><p>用户通过输入账号密码，提交到中央系统，密码正确后，视为登录成功，此时中央系统检索出用户的身份信息，以此生成特定cookie种在中央系统的域名下（而非目标登录系统），除了种这个重要及其cookie，还会产生一个code凭据，这个code是根据目标系统生成的，仅针对当前要访问的目标系统有效，且只一次性，验证后立马无效。</p><p>此时中央系统返回一个重定向到目标系统的链接，把code凭据作为参数挂载后面，除了code还有登录标志参数，利于目标系统检索判断其目的是登录。</p><h3 id="二次访问目标系统"><a href="#二次访问目标系统" class="headerlink" title="二次访问目标系统"></a>二次访问目标系统</h3><p>根据中央系统的重定向链接和code等登录相关参数，浏览器二次访问目标系统，系统检索到到登录标识且有code，则取code向中央系统验证，换取accessToken，如上所述，换取后code凭据立马失效，这一步的安全保障在于：</p><ul><li>请求发生在服务器和服务器之间</li><li>https加密链接</li><li>有BA验证</li><li>code一次性</li></ul><h4 id="用accessToken换取用户信息"><a href="#用accessToken换取用户信息" class="headerlink" title="用accessToken换取用户信息"></a>用accessToken换取用户信息</h4><p>目标服务器拿刚换取到的accessToken再次发起请求换取用户信息，如：姓名、id、邮箱等。这一步的保障在于：</p><ul><li>服务器请求服务器</li><li>https</li><li>有BA</li></ul><p>目标服务器总算拿到了用户信息，到这里中央认证在登录这一块的基本任务就完整成了，因为如何保存和处理用户信息是目标服务器的事了，只要和前端浏览器约定好登录验证方案即可，这里多种实现，有常规方案session和目前常见的JWT。</p><p>这里说一下JWT。</p><h3 id="JWT-（JSON-Web-Token）"><a href="#JWT-（JSON-Web-Token）" class="headerlink" title="JWT （JSON Web Token）"></a>JWT （JSON Web Token）</h3><p>目标系统根据用户信息以及accessToken（为什么也要包含accessToken？后续退出会说到）进行签名加密成一个token（密钥只有服务器知道），返回给前端浏览器，浏览器后续的请求都带上这个token来作为登录标志，所以后续没放目标系统收到请求中的token都会先解密出用户信息后，才会进行后续逻辑中间件的处理。JWT还有很多细节，最大的特点就是和浏览器器传输一个token密码，免去服务端保存一份用户信息，从而实现无状态的目的，减轻服务端保存session的压力和响应速度。</p><p>把token交给前端和后续请求带上token有两种方案：</p><ul><li>作为重定向的参数</li><li>种cookie</li></ul><p>请求带上token也有相应的两种（其实参数也能带，但肯定没人这么做）：</p><ul><li>放在请求头中</li><li>作为cookie</li></ul><p>这里整个登录流程就已经实现，下面说一下退出流程。</p><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>退出请求依然会带上token，根据token解密出登录信息和上述accessToken，拿accessToken去请求中央服务器的退出接口声明废弃此accessToken，然后清除cookie，如果cookie内容是token的话也就是清除了token，并在响在重定向到最开始的登录页或其他你想要的页面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CAS:中央认证服务（Central Authentication Service）。&lt;br&gt;SSO：单点登录（Single Sign On）。&lt;/p&gt;
&lt;p&gt;当一个账号能需要登录多个系统时，比如用新浪微博登录新浪官网、邮箱等，是不需要反复输入账号密码登录的，其背后的实现机
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>《金字塔原理》</title>
    <link href="http://chayangge.com/2019/03/23/%E3%80%8A%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E3%80%8B/"/>
    <id>http://chayangge.com/2019/03/23/《金字塔原理》/</id>
    <published>2019-03-23T12:49:15.000Z</published>
    <updated>2019-03-23T15:43:45.786Z</updated>
    
    <content type="html"><![CDATA[<p>其实很多书翻来覆去就说了一句话，《金字塔原理》这本书也是。<br>这句话就是写在书皮扉页上：</p><blockquote><p>金字塔的基本机构是：中心思想明确，结论先行，以上统下，归类分组，逻辑递进。先重要后次要，先全局后细节，先结论后原因，先结果后过程。</p></blockquote><p>没错，这是一本工具书，本书的所有内容无非是对这段话，在表达、沟通上的详细论证和举例绘图描述，书中法门对经常汇报工作的高层来说已经是基本常识，对新人来说也谈不上高深，毕竟有些细节旁敲侧击是听说过的，经过系统性的描述和举例后会更加深刻，会清晰认识到到这本书果然是意如其名，从而在日后的沟通、写作、汇报细节上加以联=练习使用，从而成为自己的“常识”。</p><h3 id="为什么要使用金字塔原理"><a href="#为什么要使用金字塔原理" class="headerlink" title="为什么要使用金字塔原理"></a>为什么要使用金字塔原理</h3><p>也就是为什么对外输出表达要有结构？<br>数字7，或者类似范围的数字，大概5-9之间是人脑所能hold住的并发数，管理1-3个项目还是挺轻松的，5-9个项目或信息点同时汇过来，人脑就不行了，需要排个层级顺序，利于消化，并且：</p><p>人脑天然喜欢归类、抽象和总结，比如：</p><ul><li>从繁星中看到图案</li><li>从杂乱的图中看到人脸</li></ul><p>所以保证结构输出的原因是：</p><ul><li>头脑经历有限</li><li>头脑偏好归类、抽象信息，而不是杂乱分散</li></ul><h3 id="金字塔顶尖：结论先行"><a href="#金字塔顶尖：结论先行" class="headerlink" title="金字塔顶尖：结论先行"></a>金字塔顶尖：结论先行</h3><p>一步到位告诉结果，是汇报的首要前提，不要拖泥带水讲原因细节，假设有人向你汇报，你当然最想知道的就是结果如何，其次才会想了解背后原因过程。</p><h3 id="金字塔基座：原因平级归属，有逻辑，有顺序"><a href="#金字塔基座：原因平级归属，有逻辑，有顺序" class="headerlink" title="金字塔基座：原因平级归属，有逻辑，有顺序"></a>金字塔基座：原因平级归属，有逻辑，有顺序</h3><p>给出支撑结论的依据：之所以【这个结果】，是因为：1，2，3这么几项。注意：这里的1，2，3是平级且有关联的，且都是核心重头原因，如果原因1的背后还有细节子原因，请不要不在追加在后面，而是把子原因铺在下一个层级里。</p><p>归纳论点需要注意：</p><ul><li>论点之前有关联，属于同一逻辑范畴</li><li>任意上层是对其下层的总结概括</li><li>排好顺序，排序规则：按时间、大小前提，重要顺序，步骤顺序</li></ul><p>总之：纵向总结，横向逻辑统一。</p><h3 id="思考的自下而上方法"><a href="#思考的自下而上方法" class="headerlink" title="思考的自下而上方法"></a>思考的自下而上方法</h3><p>当你暂时还锚定不了一个主题，无法确定读者疑问或读者想了解什么，也就是还没有稳住金字塔塔尖，只有一对无机构的散点描述信息时，可以按自下而上的方法，构建你的金字塔：</p><ul><li>列出所有散落的点信息</li><li>找出这些点之间的关联，肯定有平级的，有关关系的，承上启下的等等</li><li>铺平，累加，找到这些点汇聚的结论，那就是金字塔塔尖</li></ul><p>自下而上完全是这本书的意外收获。</p><h3 id="信息自我归纳"><a href="#信息自我归纳" class="headerlink" title="信息自我归纳"></a>信息自我归纳</h3><p>例子：</p><blockquote><p>日本商人加大对中国的投资<br>美国商人加大对中国的投资<br>德国商人加大对中国的投资<br>可归纳为：<br>投资商们加大对中国的投资</p></blockquote><p>例子：</p><blockquote><p>日本商人加大对中国的投资<br>日本商人加大对印尼的投资<br>日本商人加大对马来的投资<br>可归纳为：<br>日本商人加大对东南亚的投资</p></blockquote><p>归纳的前提是有共同性，如果是其他分散的无关联地区则无法归纳，要记：将一个思想与其他思想共同写进谋篇文章的唯一理由，就是这个思想有利于对一个更高层次上的思想提供解释或支持。</p><h3 id="分组原则"><a href="#分组原则" class="headerlink" title="分组原则"></a>分组原则</h3><h4 id="因果别混杂"><a href="#因果别混杂" class="headerlink" title="因果别混杂"></a>因果别混杂</h4><p>计划行动步骤中，不要把行动和结果平级列入，要把结果写成对结果的“行动”，而非在行动中插一条无行为动作的结果信息描述。</p><h4 id="MECE原则"><a href="#MECE原则" class="headerlink" title="MECE原则"></a>MECE原则</h4><ul><li>各模块相互独立（mutually exclusive），相互排斥，不重叠</li><li>穷尽所有模块（collectively exhaustive），不遗漏</li></ul><p>本书最后，引用赫伯特·西蒙：解决问题只不过是通过对问题的表述，使解决方案不言自明。</p><p>于此类似的有吉德林法则：把难题清清楚楚地写出来，便已经解决了一半。</p><p>还有：暴露问题是解决的第一步。</p><p>而金字塔原理就是帮我们更好的描述问题，输出信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实很多书翻来覆去就说了一句话，《金字塔原理》这本书也是。&lt;br&gt;这句话就是写在书皮扉页上：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;金字塔的基本机构是：中心思想明确，结论先行，以上统下，归类分组，逻辑递进。先重要后次要，先全局后细节，先结论后原因，先结果后过程。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://chayangge.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>js:模拟new</title>
    <link href="http://chayangge.com/2019/02/28/js-%E6%A8%A1%E6%8B%9Fnew/"/>
    <id>http://chayangge.com/2019/02/28/js-模拟new/</id>
    <published>2019-02-28T05:17:11.000Z</published>
    <updated>2019-04-28T08:42:13.482Z</updated>
    
    <content type="html"><![CDATA[<p>作为关键字new，也是可以模拟的，模拟之前，先看new的基本用法和作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function bar(name,age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.habit = &apos;game&apos;;</span><br><span class="line">&#125;</span><br><span class="line">bar.prototype.strength = 60;</span><br><span class="line">bar.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">let a = new bar(&apos;tom&apos;,10);</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(a.name);</span><br><span class="line">console.log(a.age);</span><br><span class="line">console.log(a.strength);</span><br><span class="line">a.sayName();</span><br></pre></td></tr></table></figure><p>实例a可以访问构造函数中的变量，也可以访问其原型prototype上的变量和方法，下面是实现，命名为objectFactory：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objectFactory(fn,a)&#123;</span><br><span class="line">    var obj = new Object();</span><br><span class="line">    var Constructor = [].shift.call(arguments);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    Constructor.apply(obj, arguments);</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，信息密度大，及其精妙。</p><p>补充用构造函数new对象的特例：构造函数返回是一个对象时直接返回对象，则返回对象(如果返回常规类型，则忽略return)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function test(a)&#123;</span><br><span class="line">    this.name = &apos;111&apos;;</span><br><span class="line">    return &#123;</span><br><span class="line">        sayName:() =&gt;&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new test();</span><br><span class="line">console.log(a);</span><br><span class="line">a.sayName() // 111</span><br></pre></td></tr></table></figure><p>所以最终实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function objectFactory()&#123;</span><br><span class="line">    var obj = new Object(),</span><br><span class="line">    // 截取fn</span><br><span class="line">    fn = [].shift.call(arguments);</span><br><span class="line">    obj.__proto__ = fn.prototype;</span><br><span class="line">    // 截取后续参数</span><br><span class="line">    var ret = fn.apply(obj, arguments);</span><br><span class="line"></span><br><span class="line">    return typeof ret === &apos;object&apos; ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为关键字new，也是可以模拟的，模拟之前，先看new的基本用法和作用：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;b
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js:模拟call、apply</title>
    <link href="http://chayangge.com/2019/02/26/js-%E6%A8%A1%E6%8B%9Fcall%E3%80%81apply/"/>
    <id>http://chayangge.com/2019/02/26/js-模拟call、apply/</id>
    <published>2019-02-26T15:08:36.000Z</published>
    <updated>2019-02-26T18:25:51.232Z</updated>
    
    <content type="html"><![CDATA[<p>call的用法：借窝下蛋，使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p><p>看个应用场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var value = 456;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    value: 11,</span><br><span class="line">    test: function()&#123;</span><br><span class="line">        console.log(123);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function test()&#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">test.call(obj);</span><br></pre></td></tr></table></figure><p>如果不用call，我们的代码不得不这样，把test放到obj里才行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    // 需要把函数放在obj里才行</span><br><span class="line">    bar: function() &#123;</span><br><span class="line">        console.log(this.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar(); // 1</span><br></pre></td></tr></table></figure><p>demo中通过调用call，让test中this的指向改为obj。</p><h3 id="模拟call"><a href="#模拟call" class="headerlink" title="模拟call"></a>模拟call</h3><p>原生的call方法是挂载在Function.prototype上的，下面就模拟实现一个call2：<br>模拟原理：</p><ul><li>先把函数放在obj里，获得了想要的this指向</li><li>执行obj.函数</li><li>删除obj.函数，保证obj原状不变</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 = function(obj)&#123;</span><br><span class="line">    obj.fn = this; // 重点：this指向的实例，Function的实例就是函数bar</span><br><span class="line">    obj.fn();</span><br><span class="line">    delete fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var foo = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line">bar.call2(foo); // 1</span><br></pre></td></tr></table></figure><p>到这原理就讲完了，但call是能带参数的，且还有类似固定参数的apply呢<br>实现带参call2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 = function(obj,a,b)&#123;</span><br><span class="line">    obj.fn = this;</span><br><span class="line">    obj.fn(a,b);</span><br><span class="line">    delete fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var foo = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar(a,b) &#123;</span><br><span class="line">    console.log(this.value,a,b);</span><br><span class="line">&#125;</span><br><span class="line">bar.call2(foo,1,2); // 1,1,2</span><br></pre></td></tr></table></figure><p>但现实中call的参数是不固定的，第第一位始终是要嫁接的obj，所以参数只能从arguments数组的第1为开始取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 = function(context) &#123;</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var args = [];</span><br><span class="line">    for(var i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    eval(&apos;context.fn(&apos; + args +&apos;)&apos;); // 重点：用eval拼接出参数（a,b,c）的效果，args会自动调用toString方法</span><br><span class="line">    delete context.fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var foo = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar(name, age) &#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">    console.log(age)</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call2(foo, &apos;kevin&apos;, 18); </span><br><span class="line">// kevin</span><br><span class="line">// 18</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><p>有些函数需要返回：比如函数结果是return一个什么东西，比如return 一个obj对象之类:<br>还有 call可以传null的，传null意味着在全局window上执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function bar(name, age) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        value: this.value,</span><br><span class="line">        name: name,</span><br><span class="line">        age: age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bar() // return出一个对象</span><br></pre></td></tr></table></figure><p>这里也是可以轻松实现的，原理是把fn执行的结果收集起来，再用return扔出去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 = function(context) &#123;</span><br><span class="line">    var context = context || window; // 为null时，context为window</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var args = [];</span><br><span class="line">    for(var i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    let result = eval(&apos;context.fn(&apos; + args +&apos;)&apos;); // 重点：用result手机函数运行结果，并return出去</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result; // return 出去</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var foo = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar(name, age) &#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">    console.log(age)</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call2(foo, &apos;kevin&apos;, 18); </span><br><span class="line">// kevin</span><br><span class="line">// 18</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><h3 id="apply的模拟实现"><a href="#apply的模拟实现" class="headerlink" title="apply的模拟实现"></a>apply的模拟实现</h3><p>apply的唯一区别就是参数固定，所以第二个参数直接一个数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.apply = function (context, arr) &#123;</span><br><span class="line">    var context = Object(context) || window;</span><br><span class="line">    context.fn = this;</span><br><span class="line"></span><br><span class="line">    var result;</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        var args = [];</span><br><span class="line">        for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(&apos;arr[&apos; + i + &apos;]&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟bind"><a href="#模拟bind" class="headerlink" title="模拟bind"></a>模拟bind</h3><p>先看看bind的特性：</p><ul><li>依然是借窝下蛋的功能</li><li>但返回一个新的函数</li><li>函数可传参，且参数可以再bind的时候产一部分，在执行的时候再传一部分</li></ul><p>最简单实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind2 = function(obj)&#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        return self.apply(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var foo = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line">let a = bar.bind2(foo);</span><br><span class="line">console.log(&apos;a:&apos;,a);</span><br><span class="line">a() // 1</span><br></pre></td></tr></table></figure><p>实现和原理见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;call的用法：借窝下蛋，使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。&lt;/p&gt;
&lt;p&gt;看个应用场景：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js:变量解析</title>
    <link href="http://chayangge.com/2019/02/19/js-%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%90/"/>
    <id>http://chayangge.com/2019/02/19/js-变量解析/</id>
    <published>2019-02-18T16:17:58.000Z</published>
    <updated>2019-02-20T06:10:20.027Z</updated>
    
    <content type="html"><![CDATA[<p>js在执行前会创建可执行上下文，执行上下文中中包含：</p><ul><li>变量对象</li><li>作用域链</li><li>this</li></ul><p>执行上下文中的变量我们称为：活动对象(activation object, AO)。</p><p><strong>js对执行上下文中的代码有两部处理：1.进入执行上下文，进行各自的声明；2.执行，对声明赋值</strong><br>进入阶段，其中变量对象的状态为：</p><ul><li>arguments即形参，被赋值的形参为key:value，未赋值的为key:undefined</li><li>函数声明，注意：函数的声明一定提前于变量</li><li>变量声明，只有声明变量占位，并没有值</li></ul><p>demo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test(item1,item2)&#123;</span><br><span class="line">    console.log(item1,item2);  // 1,undefined</span><br><span class="line">    console.log(a); // undefined</span><br><span class="line">    console.log(c); // c()&#123;&#125;</span><br><span class="line">    var a = 3;</span><br><span class="line">    function c()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">test(1);</span><br></pre></td></tr></table></figure><p>进入阶段的AO是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        1: undefined,</span><br><span class="line">        length: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    a: undefined,</span><br><span class="line">    c: reference to function c()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之所以能正常打印a，是因为执行打印时，函数已经提前【扫描】了内部变量，arguments作为实参，有实参则有值，无实参则undefined，函数提前，变量声明提前，只是没赋值，此时为undefined，执行到后续的的复制命令时a才会为3.</p><p>改一下，把内部的var a = 3;去除var，变为a = 3 时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test(item1,item2)&#123;</span><br><span class="line">    console.log(item1,item2);  // 1,undefined</span><br><span class="line">    console.log(a); // 此处会报错：ReferenceError: a is not defined</span><br><span class="line">    console.log(c); </span><br><span class="line">    a = 3;</span><br><span class="line">    function c()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">test(1);</span><br></pre></td></tr></table></figure><p>因为去除var后，没有变量声明，在进入时，上下文中根本不会声明变量a，在执行阶段发现本作用域中没有a，则往上找，依然没有，则报错。<br>在进入阶段的AO为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        1: undefined,</span><br><span class="line">        length: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    // 根本没有a，也不存在undefined,</span><br><span class="line"></span><br><span class="line">    c: reference to function c()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>函数优于变量提前声明</li><li>变量与形参重名时，变量声明不影响形参，如下demo：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function test(item1,item2)&#123;</span><br><span class="line">    console.log(item1,item2); // 1, undefined</span><br><span class="line">    console.log(c); // c()&#123;&#125;  而不是undefined，因为函数提前</span><br><span class="line">    var c = 3;</span><br><span class="line">    function c()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    var item1;</span><br><span class="line">    console.log(item1); // 依然是1，没赋值，不会影响形参item1</span><br><span class="line">&#125;</span><br><span class="line">test(1);</span><br></pre></td></tr></table></figure><h3 id="与静态作用域的关系"><a href="#与静态作用域的关系" class="headerlink" title="与静态作用域的关系"></a>与静态作用域的关系</h3><p>上文中说过js的作用域是静态的，函数无论在哪里执行，其内部变量的作用域始终为创建函数是固定的，通过观察AO发现果然如此，在函数执行前去，创建作用域栈，解析当前作用域下的变量，产生了固定的AO。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;js在执行前会创建可执行上下文，执行上下文中中包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量对象&lt;/li&gt;
&lt;li&gt;作用域链&lt;/li&gt;
&lt;li&gt;this&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行上下文中的变量我们称为：活动对象(activation object, AO)。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js:静态作用域</title>
    <link href="http://chayangge.com/2019/02/18/js-%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://chayangge.com/2019/02/18/js-静态作用域/</id>
    <published>2019-02-18T05:03:42.000Z</published>
    <updated>2019-02-18T06:24:06.246Z</updated>
    
    <content type="html"><![CDATA[<p>作用域指代码中定义变量的区域，js是静态作用于，核心点在于：无论function在哪里执行，function中使用的变量，始终为定义function时的变量。<br><a id="more"></a><br>demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value = 2;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // 1</span><br></pre></td></tr></table></figure></p><p>无论foo在哪里执行，其寻找变量的始终为创建时全局的value，而非bar中定义的value。如果js是动态作用域那打印的肯定是2了。</p><p>换个复杂点的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><p>以及：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure><p>毫无疑问：都是local scope，无论f在哪执行，哪怕被return出去，其中变量作用域始终为创建时的“local scope”。</p><h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><p>上述demo中两个checkscope的实现方式虽然结果相同，但执行上下文栈是不同的：<br>当js执行一个函数的时候，会创建一个执行上下文压栈，当有n个执行任务的时候，通过执行上下文栈来管理执行顺序，然后挨个执行出栈，最后的栈低永远是全局上下文globalContext。<br>demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fun3() &#123;</span><br><span class="line">    console.log(&apos;fun3&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun2() &#123;</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun1() &#123;</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure></p><p>所以执行上下文栈为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//先执行fn1</span><br><span class="line">ECStack.push(fn1)</span><br><span class="line"></span><br><span class="line">// 发现fn1里调用了fn2，再次创建一个执行上下文入栈</span><br><span class="line">ECStack.push(fn2)</span><br><span class="line"></span><br><span class="line">// 发现fn2里调用了fn3，再次创建一个执行上下文入栈</span><br><span class="line">ECStack.push(fn3)</span><br><span class="line"></span><br><span class="line">// 终于fn3得到执行，pop出栈</span><br><span class="line">ECStack.pop();</span><br><span class="line">// fun2执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">// fun1执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">// 最后ECStack中剩下globalContext</span><br></pre></td></tr></table></figure></p><p>那上述checkscope的demo中两个虽结果一样，但执行上线文栈为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ECStack.push(checkscope)</span><br><span class="line"></span><br><span class="line">//发现里面调用了f()</span><br><span class="line">ECStack.push(f)</span><br><span class="line"></span><br><span class="line">// 终于f得到执行，pop出栈</span><br><span class="line">ECStack.pop();</span><br><span class="line">// checkscope执行完毕</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure><p>第二个checkscope()();的例子为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ECStack.push(checkscope)</span><br><span class="line"></span><br><span class="line">//checkscope()运行结束了，pop</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">// 发现checkscope()后面又有个()，也就是还有执行任务f，那再push</span><br><span class="line">ECStack.push(f)</span><br><span class="line">// f执行完毕</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure><p>完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作用域指代码中定义变量的区域，js是静态作用于，核心点在于：无论function在哪里执行，function中使用的变量，始终为定义function时的变量。&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js:按值传递</title>
    <link href="http://chayangge.com/2019/02/16/js-%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    <id>http://chayangge.com/2019/02/16/js-按值传递/</id>
    <published>2019-02-16T07:29:10.000Z</published>
    <updated>2019-02-16T08:03:25.614Z</updated>
    
    <content type="html"><![CDATA[<p>js是按值传递的，这个值对原始数据类型来说是value，对引用型数据来说是引用（即地址）；<br><a id="more"></a><br>demo1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function f(a,b,c) &#123;</span><br><span class="line">   a = 3;</span><br><span class="line">   b.push(&quot;foo&quot;);</span><br><span class="line">   c.first = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x = 4;</span><br><span class="line">var y = [&quot;eeny&quot;, &quot;miny&quot;, &quot;mo&quot;];</span><br><span class="line">var z = &#123;first: true&#125;;</span><br><span class="line">f(x,y,z); // x:3 y:[&quot;eeny&quot;, &quot;miny&quot;, &quot;mo&quot;, &apos;foo&apos;]  z: &#123;first: false&#125;</span><br></pre></td></tr></table></figure></p><p>x 是原始数据，y、z是引用数据，传入函数内的是x的值3，y、z的引用地址，所以内部通过地址引用操作内存【堆】中的引用型数据。</p><h3 id="共享传递-？"><a href="#共享传递-？" class="headerlink" title="共享传递 ？"></a>共享传递 ？</h3><p>demo2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line">function foo(o) &#123;</span><br><span class="line">    o = 2;</span><br><span class="line">    console.log(o); //2</span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line">console.log(obj.value) // 1</span><br></pre></td></tr></table></figure></p><p>上述例子中obj传入函数中的是引用地址的拷贝，被命令为o，当这个地址被重新复制后，切断了原有向堆中的指向，被新赋值为原始数据2，而堆中的数据不变，且依然被obj变量指向着。 </p><p>这也被称为共享传递，但因为共享传递中传递的是地址，地址被一个变量代表着，所以在《js高程》中称js为值传递。</p><p>demo2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;a:1&#125;;</span><br><span class="line">a.x = a = &#123;a:2&#125;;</span><br><span class="line">console.log(a); // &#123;a:2&#125;</span><br><span class="line">console.log(a.x); // undefined  ??</span><br></pre></td></tr></table></figure><p>首先复制运算从右向左，且.符号优先级最大，a为{a:1}的引用地址（是个变量值），真正的引用数据有两个分别是：{a:1}和{a:2}，那么赋值运算可拆解为：</p><p>a.x = a = {a:2}; （新内存：{a:2}）赋值给 ==&gt; (引用地址a) 赋值给==&gt; （原内存a：{a:1}）.x</p><p>所以原内位置的数据被修改为：{a:1,x:{a:2}}<br>变量a指向的是新创建的内存：{a:2}<br>所以：a是{a:2} a.x是undefined<br>而老内存{a:1,x:{a:2}} 因为已经没有被任何变量引用，而被销毁。</p><p>为了验证老内存，防止被销毁，新建一个变量b来指向它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;a:1&#125;;</span><br><span class="line">let b = a;</span><br><span class="line">a.x = a = &#123;a:2&#125;;</span><br><span class="line">console.log(a); // &#123;a:2&#125;</span><br><span class="line">console.log(a.x); // undefined </span><br><span class="line">console.log(b); // &#123;a:1,x:&#123;a:2&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>变量b始终指向老内存{a:1}，且老内存被追加属性x后，不会被销毁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js是按值传递的，这个值对原始数据类型来说是value，对引用型数据来说是引用（即地址）；&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>package.json散落知识点</title>
    <link href="http://chayangge.com/2019/01/02/package.json%E6%95%A3%E7%82%B9%E6%8B%BE%E9%81%97/"/>
    <id>http://chayangge.com/2019/01/02/package.json散点拾遗/</id>
    <published>2019-01-02T03:07:16.000Z</published>
    <updated>2019-01-02T06:10:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集散落的package.json相关知识，日后会不断丰富和补充：<br><a id="more"></a></p><h3 id="自定义命令和内置命令"><a href="#自定义命令和内置命令" class="headerlink" title="自定义命令和内置命令"></a>自定义命令和内置命令</h3><p>我们都知道可以再script中定义命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;gulp&quot;,</span><br><span class="line">    &quot;mock-start&quot;: &quot;XXX&quot;,</span><br><span class="line">    &quot;lc-mock-start&quot;: &quot;XXX&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;npm run lint&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>但这些命令一些可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure></p><p>有些则需要加run才行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run mock-start</span><br></pre></td></tr></table></figure></p><p>不需要加run的就是npm内置命令，出start之外还有：</p><ul><li>test</li><li>stop</li><li>restart</li></ul><h3 id="语义化版本号"><a href="#语义化版本号" class="headerlink" title="语义化版本号"></a>语义化版本号</h3><p>约定一个包的版本号包含3个数字：主版本号.小版本号.修订版本号。</p><ul><li>MAJOR 对应大的版本号迭代，做了不兼容旧版的修改时要更新 MAJOR 版本号</li><li>MINOR 对应小版本迭代，发生兼容旧版API的修改或功能更新时，更新MINOR版本号</li><li>PATCH 对应修订版本号，一般针对修复 BUG 的版本号<br>具体见：<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">https://semver.org/lang/zh-CN/</a></li></ul><h3 id="版本匹配"><a href="#版本匹配" class="headerlink" title="版本匹配"></a>版本匹配</h3><p>经常看到入校版本信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">   &quot;copy-to-clipboard&quot;: &quot;^3.0.8&quot;,</span><br><span class="line">   &quot;immutable&quot;: &quot;^3.8.2&quot;,</span><br><span class="line">   &quot;react&quot;: &quot;~16.3.2&quot;,</span><br><span class="line">   &quot;react-dom&quot;: &quot;*16.3.2&quot;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>版本前有^和~两个符号，代表的意思分别为：</p><ul><li>^ 大版本匹配：如^3.0.8会匹配大版本3下的所有小版本（从3.0.0到3.9.9）</li><li>~ 小版本匹配：如~3.0.8会匹配小版本3.0.X下的所有小版本(从3.0.0到3.0.9)</li><li>*代表安装最新版本的包</li></ul><p>所以不推荐^和*</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文收集散落的package.json相关知识，日后会不断丰富和补充：&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>笔尖下的深刻——村上春树</title>
    <link href="http://chayangge.com/2018/12/28/%E7%AC%94%E5%B0%96%E4%B8%8B%E7%9A%84%E6%B7%B1%E5%88%BB%E2%80%94%E2%80%94%E6%9D%91%E4%B8%8A%E6%98%A5%E6%A0%91/"/>
    <id>http://chayangge.com/2018/12/28/笔尖下的深刻——村上春树/</id>
    <published>2018-12-28T08:57:33.000Z</published>
    <updated>2018-12-28T11:40:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章太美，忍不住挂在博客上：<br><a id="more"></a></p></blockquote><hr><p>每一个人都有属于自己的一片森林，迷失的人迷失了，相逢的人会再相逢。</p><p>如果我爱你，而你也正巧的爱我。你头发乱了时候，我会笑笑的替你拨一波，然后，手还留恋的在你发上多待几秒。但是，如果我爱你，而你不巧的不爱我。你头发乱了，我只会轻轻的告诉你，你头发乱了喔。这大概是最纯粹的爱情观，如若相爱，便携手到老;如若错过，便护他安好。</p><p>尽管世界上有那般广阔的空间，而容纳你的空间——虽然只需一点点——却无处可寻。</p><p>于是我关闭我的语言，关闭我的心，深沉的悲哀是连眼泪这形式都无法采取的东西。</p><p>你要做一个不动声色的大人了。不准情绪化，不准偷偷想念，不准回头看。去过自己另外的生活。你要听话，不是所有的鱼都会生活在同一片海里。</p><p>我一直以为人是慢慢变老的，其实不是，人是一瞬间变老。</p><p>试着这样想：我们每一个人，都或多或少地，是一枚鸡蛋。我们每一个人都是一个独特的、不可替代的灵魂，而这灵魂覆盖着一个脆弱的外壳。这就是我自己的真相，而且这也是你们每一个人的真相。</p><p>不管全世界所有人怎么说，我都认为自己的感受才是正确的。无论别人怎么看，我绝不打乱自己的节奏。喜欢的事自然可以坚持，不喜欢的怎么也长久不了。</p><p>每一次，当他伤害我时，我会用过去那些美好的回忆来原谅他，然而，再美好的回忆也有用完的一天，到了最后只剩下回忆的残骸，一切都变成了折磨，也许我的确是从来不认识他。</p><p>这是个无情的世界，因为有希望的地方就必定有磨炼。</p><p>孤独一人也没关系，只要能发自内心地爱着一个人，人生就会有救。哪怕不能和他生活在一起。</p><p>人，人生，在本质上是孤独的，无奈的。所以需要与人交往，以求相互理解。然而相互理解果真可能吗?不，不可能，宿命式的不可能，寻求理解的努力是徒劳的。与其勉强通过交往来消灭孤独，化解无奈，莫如退回来把玩孤独，把玩无奈!</p><p>世界上有什么不会失去的东西吗？我相信有，你也最好相信。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章太美，忍不住挂在博客上：&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack loader</title>
    <link href="http://chayangge.com/2018/12/24/webpack%20loader/"/>
    <id>http://chayangge.com/2018/12/24/webpack loader/</id>
    <published>2018-12-23T17:36:34.000Z</published>
    <updated>2018-12-23T17:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先熟悉loader"><a href="#先熟悉loader" class="headerlink" title="先熟悉loader"></a>先熟悉loader</h3><p>webpack只能处理js，对于非js的文件需要对应的loader转换成webpack能处理的模块，在进行打包，如JSX、TS、less等。</p><p>loader本质上是一个function，且按照node普通模块的方式编写，既可以是本地的一个文件，也可以打成一个npm包（项目中都是npm）。function用参数传入代码，然后按转换代码，最后输出代码。</p><h3 id="loader基本用法"><a href="#loader基本用法" class="headerlink" title="loader基本用法"></a>loader基本用法</h3><p>官方是使用方法这里过多介绍，只说明一下自己开发的本地loader使用方式，下面自己实现处理less的两个常用loader，分别为’style-loader’, ‘less-loader’，后者翻译less，前者把翻译后的css插入前端代码中。</p><p>在webpack.config.js中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/index.js&apos;, // 入口文件</span><br><span class="line">    output: &#123; // webpack打包后出口文件</span><br><span class="line">        filename: &apos;build.js&apos;, // 打包后js文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;) // 打包后自动输出目录</span><br><span class="line">    &#125;,</span><br><span class="line">    resolveLoader: &#123;</span><br><span class="line">        // 定义自己的loader位置</span><br><span class="line">        modules: [path.resolve(__dirname, &apos;loaders&apos;)]</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &apos;source-map&apos;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        // loader 默认从右向左、从下往上执行，可用enforce：‘pre’ normal,inlineLoader,post设定最先执行</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.less$/,</span><br><span class="line">                use: [&apos;style-loader&apos;, &apos;less-loader&apos;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如上所示，用resolveLoader定义了loader的读取位置为本地的loaders文件夹，下面在该文件夹中定义这两个laoder的js文件，先以less-loader为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function loader (source) &#123;</span><br><span class="line">    // 这里处理source</span><br><span class="line">    console.log(&apos;我是自定义loader&apos;);</span><br><span class="line">    return source;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure></p><p>此时运行webpack，会执行此loader并打印:’我是自定义loader。</p><p>loader作为一个流水线上的某个处理环节，传入了内容（String或Buffer），处理内容，最后输出内容，且输出作为下一个loader的输入，下面加入处理程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let less = require(&apos;less&apos;);</span><br><span class="line">function loader (source) &#123;</span><br><span class="line">    console.log(&apos;run loader...222&apos;, source);</span><br><span class="line">    console.log(&apos;this:&apos;, this);</span><br><span class="line">    let css;</span><br><span class="line">    less.render(source, function (error, output) &#123;</span><br><span class="line">        css = output.css;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(&apos;我是翻译后的css:&apos;, css);</span><br><span class="line">    return css;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure></p><p>至此，一个最基本的less文件loader就已经实现。</p><p>下面是style-loader，其作用是把css代码按最基础的方式插入页面中，所谓最基础的方式就是把css代码拼到style标签中，单后插入head标签里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function loader (source) &#123;</span><br><span class="line">    let str = `</span><br><span class="line">        let style = document.createElement(&apos;style&apos;);</span><br><span class="line">        style.innerHTML = $&#123;JSON.stringify(source)&#125;</span><br><span class="line">        document.head.appendChild(style)</span><br><span class="line">    `;</span><br><span class="line">    console.log(&apos;我是拼接好的插入代码：&apos;, str);</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure></p><p>运行webpack –mode development，会看到输出结果，并在dist目录中的未压缩build.js中看到具体的css代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/***/ &apos;./src/index.js&apos;:</span><br><span class="line">    /*! **********************!*\</span><br><span class="line">  !*** ./src/index.js ***!</span><br><span class="line">  \**********************/</span><br><span class="line">    /*! no static exports found */</span><br><span class="line">    /***/ function (module, exports, __webpack_require__) &#123;</span><br><span class="line">        __webpack_require__(/*! ./index.less */ &apos;./src/index.less&apos;);</span><br><span class="line">        document.querySelector(&apos;#root&apos;).innerHTML = &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos;;</span><br><span class="line">        /***/ &#125;,</span><br><span class="line"></span><br><span class="line">    /***/ &apos;./src/index.less&apos;:</span><br><span class="line">    /*! ************************!*\</span><br><span class="line">  !*** ./src/index.less ***!</span><br><span class="line">  \************************/</span><br><span class="line">    /*! no static exports found */</span><br><span class="line">    /***/ function (module, exports) &#123;</span><br><span class="line">        let style = document.createElement(&apos;style&apos;);</span><br><span class="line">        style.innerHTML = &apos;h1 &#123;\n  color: red;\n&#125;\n&apos;;</span><br><span class="line">        document.head.appendChild(style);</span><br><span class="line">        /***/ &#125;</span><br><span class="line"></span><br><span class="line">/******/ &#125;);</span><br></pre></td></tr></table></figure><p>在浏览器打开，将看到红色的hello word，说明两个loader已经正常运行。</p><h3 id="pitch"><a href="#pitch" class="headerlink" title="pitch"></a>pitch</h3><p>每个loader的function都有pitch属性方法，虽然loader的执行方式是从右向左，总下往上，但每个loader的pich是按常规顺序执行的，可以在某个laoder中打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function loader (source) &#123;</span><br><span class="line">    let str = `</span><br><span class="line">        let style = document.createElement(&apos;style&apos;);</span><br><span class="line">        style.innerHTML = $&#123;JSON.stringify(source)&#125;</span><br><span class="line">        document.head.appendChild(style)</span><br><span class="line">    `;</span><br><span class="line">    console.log(&apos;我是拼接好的插入代码：&apos;, str);</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line">loader.pitch = function () &#123;</span><br><span class="line">    console.log(&apos;我是less-loader的pitch，我先执行&apos;);</span><br><span class="line">    //return &apos;source&apos; 一旦return，后续的loader将不执行</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure><p>当pitch中有return时，不在执行后面的loader，pitch在内部是以递归方式执行，当递归到底时，再执行loader，类似于koa中间件的洋葱模型，或理解为先入后出的栈模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|- style-loader `pitch`</span><br><span class="line">  |- less-loader `pitch`</span><br><span class="line">    // 递归到底</span><br><span class="line">  |- less-loader normal execution</span><br><span class="line">|- style-loader normal execution</span><br></pre></td></tr></table></figure></p><p>上面所写的两个loader过于简单，未涉及loader中的this，在每一个loader的上下文中都能通过this获取到loader的相关API，应对更多的功能场景，关于更多this上的API见<a href="https://webpack.js.org/api/loaders/" target="_blank" rel="noopener">文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;先熟悉loader&quot;&gt;&lt;a href=&quot;#先熟悉loader&quot; class=&quot;headerlink&quot; title=&quot;先熟悉loader&quot;&gt;&lt;/a&gt;先熟悉loader&lt;/h3&gt;&lt;p&gt;webpack只能处理js，对于非js的文件需要对应的loader转换成webpac
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="http://chayangge.com/2018/11/26/Promise/"/>
    <id>http://chayangge.com/2018/11/26/Promise/</id>
    <published>2018-11-25T17:52:02.000Z</published>
    <updated>2018-11-26T02:44:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>越是高级语言，高封装度的框架，使用起来代码越倾向于配置，就像css，几乎就是一门纯配置语言。<br>Promise一直在用，基本都是在写Promise的配置，现在想想还是研究一下内部。<br><a id="more"></a><br>Promise主要解决嵌套异步回调问题，退一步想，只是代码形式上的“重组”，而promise就是重组嵌套代码的盒子，这个盒子规定：把触发逻辑写在resolve里，回调都写在then里，这样的代码形式则变得优雅很多。</p><p>回调地狱：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;./test.txt&apos;,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">    fs.readFile(data,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">        fs.readFile(data,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">            console.log(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>Promis后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function read(filePath,encoding)&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        fs.readFile(filePath,encoding,(err,data)=&gt;&#123;</span><br><span class="line">            if(err) &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(&apos;./test.txt&apos;,&apos;utf8&apos;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    return read(data,&apos;utf8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    return read(data,&apos;utf8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    return data.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)...</span><br></pre></td></tr></table></figure></p><p>当然，应用广泛的Promise是有规范的，可以根据规范自己实现。规范也是人定的，甚至还可以抛弃规范去写自己心目中的代码。</p><p>如上面所说，Promise是代码形式上的“重组”工具，把触发代码和回调代码，以利于阅读和维护的方式重组，其中触发代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(filePath,encoding,(err,data)=&gt;&#123;</span><br><span class="line">    if(err) &#123;</span><br><span class="line">    reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>回调代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这样理解起来，对Promise整体就有了全局的认识，接下来要实现的就是这个工具，这个工具的核心是：</p><ul><li>1.触发函数在新建Promise时先执行，并根据结果设定好是走resolve还是reject</li><li>2.then里的回调函数在触发后执行，这就意味着要先注册这些回调（resolve回调和reject的回调）</li><li>3.Promise要能链式调用，且每个链式产生的是一个全新的Promise（非jQuery中直接return this，而是return new Promise）</li></ul><p>###最小Promise<br>先实现一个最小功能的Promise，仅实现上述1，2功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Promisee(fn)&#123;</span><br><span class="line">    this.state = &apos;PENDING&apos;;</span><br><span class="line">    this.value = null;</span><br><span class="line"></span><br><span class="line">    resolve = (value) =&gt; &#123;</span><br><span class="line">        this.state = &apos;RESOLVED&apos;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;;</span><br><span class="line">    reject = (error) =&gt; &#123;</span><br><span class="line">        this.state = &apos;REJECTED&apos;</span><br><span class="line">        this.value = error;</span><br><span class="line">    &#125;;</span><br><span class="line">    fn(resolve,reject)</span><br><span class="line">&#125;</span><br><span class="line">Promisee.prototype.then = function(onResole,onReject)&#123;</span><br><span class="line">        if(this.state === &apos;RESOLVED&apos;)&#123;</span><br><span class="line">            onResole(this.value)</span><br><span class="line">        &#125;</span><br><span class="line">        else if(this.state === &apos;REJECTED&apos;)&#123;</span><br><span class="line">            onReject(this.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p>触发逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let t = new Promisee((resolve,reject) =&gt; &#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    resolve(a);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t.then((value)=&gt;&#123;</span><br><span class="line">    console.log(&apos;执行成功：&apos;,value);</span><br><span class="line">&#125;,(value) =&gt; &#123;</span><br><span class="line">    console.log(&apos;执行失败：&apos;,value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上述就是最简易的Promise，上来就先执行了resolve，然后执行了then中onResole的回调。</p><p>但在实际中Promise的触发逻辑都是异步的，比如发起请求，这里用setTimeout模拟：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let t = new Promisee((resolve,reject) =&gt; &#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(a);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里因为触发函数是异步的，所以then优先于resolve执行，而此时的状态还是最初的PEDDING，为此，Promise要继续丰富这种情况，保证then里的代码优先注册，必须当resolve执行后，才执行then中注册的回调：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function Promisee(fn)&#123;</span><br><span class="line">    this.state = &apos;PENDING&apos;;</span><br><span class="line">    this.value = null;</span><br><span class="line">    this.onResolvedCallback = [];</span><br><span class="line">    this.onRejectedCallback = [];</span><br><span class="line"></span><br><span class="line">    resolve = (value) =&gt; &#123;</span><br><span class="line">        this.state = &apos;RESOLVED&apos;</span><br><span class="line">        this.value = value;</span><br><span class="line">        console.log(this.onResolvedCallback.length);</span><br><span class="line">        for(var i = 0; i &lt; this.onResolvedCallback.length; i++) &#123;</span><br><span class="line">            this.onResolvedCallback[i](value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    reject = (error) =&gt; &#123;</span><br><span class="line">        this.state = &apos;REJECTED&apos;</span><br><span class="line">        this.value = error;</span><br><span class="line">        for(var i = 0; i &lt; this.onRejectedCallback.length; i++) &#123;</span><br><span class="line">            this.onRejectedCallback[i](error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    fn(resolve,reject)</span><br><span class="line">&#125;</span><br><span class="line">Promisee.prototype.then = function(onResole,onReject)&#123;</span><br><span class="line">        if(this.state === &apos;RESOLVED&apos;)&#123;</span><br><span class="line">            onResole(this.value)</span><br><span class="line">        &#125;</span><br><span class="line">        else if(this.state === &apos;REJECTED&apos;)&#123;</span><br><span class="line">            onReject(this.value)</span><br><span class="line">        &#125;</span><br><span class="line">        else if(this.state === &apos;PENDING&apos;)&#123;</span><br><span class="line">            this.onResolvedCallback.push(onResole);</span><br><span class="line">            this.onRejectedCallback.push(onReject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p>仔细对比改造前后的代码，会发现有以下核心改动点：</p><ul><li>then里当PENDING状态时分别存到onResolvedCallback和onRejectedCallback数组里，解决了上述中因异步触发函数导致缺失PENDING状态的问题</li><li>resolve或reject执行时，遍历各自的数组栈，把之前then中存进去的回调函数通通在此时执行</li></ul><p>这时候的触发函数终于可以写成常见的异步了。</p><p>下面只剩下一个问题3：then链式调用，then返回的是一个全新的Promise，需在then的三种情况下都返回一个new Promise，且新promise的输入是上一个promise的输出，也就是上一个promise中then里的回调函数执行结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;越是高级语言，高封装度的框架，使用起来代码越倾向于配置，就像css，几乎就是一门纯配置语言。&lt;br&gt;Promise一直在用，基本都是在写Promise的配置，现在想想还是研究一下内部。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符、ASCII码、Unicode、UTF-8、emoji</title>
    <link href="http://chayangge.com/2018/10/30/UTF-8/"/>
    <id>http://chayangge.com/2018/10/30/UTF-8/</id>
    <published>2018-10-30T02:30:52.000Z</published>
    <updated>2018-12-30T13:30:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>计算机供01高低电位表示信息，01也是最小逻辑单元。</p><p>一个字节由8个bit位表示，也就是一个字节最多能表示256个字符（256种组合）</p><p>ASCII码就是这种表示方法，但只用钱7位表达了128个字符，开头都是0，这128个字符包含常见的英文字母大小写，以及32个不能打印出来的控制符。</p><p>英文肯定是够用了，但有上万个字符的中文及其他语言就不行了。</p><p>所以GB2312编码来了，用两个字节表示一个汉字，也就是16个bit位，终于满足所有汉字了。</p><p>但每个语言都搞一套编码，不够国际化，别的编码方式的浏览器打开中文都是乱码。</p><p>所以Unicode出现了，uni + code （统一 + 编码）</p><p>终于能把全世界的语言字符表达完了。</p><p>但有个问题：浪费存储空间，很多排在后面的特殊字符要用4个甚至给更多字符表达，那就是32个bit位啊，如果只表达一个英文字母，8位就足够足够了，剩余的位置都要补0，空占位而已。</p><p>所以UTF-8 出现了。</p><p>UTF-8可以非常灵活根据不同字符，采用1-4个字符去表达，比如我们熟知的：英文1个字符，汉字两个字符，但要知道，有别的语言字符需要3-4个字符才能表达。</p><p>文字字符太单调了，不够生动形象，全球人类都能通过笑和哭的表情来表达信息，如果能有表情就好了，怎么办呢？</p><p>二次元的国都 —— 日本，率先发明了emoji，来解决这个问题，比如：😯😈😎😆☹️</p><p>e表示”絵”，moji表示”文字”。连在一起，就是”絵文字”，是不是很日文？</p><p>流行以后难免要统一起来，那就国际化吧：Unicode开始接纳emoji。所以，对计算机来说：</p><p>emoji就是字符，emoji就是字符，emoji就是字符。</p><p>现在emoji越来越多，都在<a href="http://www.unicode.org/emoji/charts/full-emoji-list.html" target="_blank" rel="noopener">这里</a>：<a href="http://www.unicode.org/emoji/charts/full-emoji-list.html" target="_blank" rel="noopener">http://www.unicode.org/emoji/charts/full-emoji-list.html</a></p><p>将来随着新名词的出现和老词汇的丰富，还会有更多emoji表情出现，所以我们正在经历电脑字符愈来愈多的年代。</p><p>为什么同样的笑脸emoji在不同的平台上长得稍微有些不一样呢？比如微信里的，和电脑里的，或其他语言平台安卓下的？</p><p>因为：Unicode只规定了Emoji在某个01组合位置的含义，并没有规定它的长相。所以假设1000101表示大笑，那不同的平台只要给出符合自己民情的笑脸样式即可。</p><p>话题跑远了，回到技术话题：当百度搜索你好时，看到的请求编码是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/s?wd=%E4%BD%A0%E5%A5%BD</span><br></pre></td></tr></table></figure></p><p>很明显汉字【你好】被编码成了【%E4%BD%A0%E5%A5%BD】，且还有这多%%%。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机供01高低电位表示信息，01也是最小逻辑单元。&lt;/p&gt;
&lt;p&gt;一个字节由8个bit位表示，也就是一个字节最多能表示256个字符（256种组合）&lt;/p&gt;
&lt;p&gt;ASCII码就是这种表示方法，但只用钱7位表达了128个字符，开头都是0，这128个字符包含常见的英文字母大小
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MongoDB备忘</title>
    <link href="http://chayangge.com/2018/09/17/MongoDB%E5%A4%87%E5%BF%98/"/>
    <id>http://chayangge.com/2018/09/17/MongoDB备忘/</id>
    <published>2018-09-17T06:39:30.000Z</published>
    <updated>2018-09-29T09:57:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近因业务原因，需登录机器手动操作MongoDB，每次操作每次查，现备份一次，方便日后：<br><a id="more"></a></p><ul><li>先登录机器</li><li>链接MongoDB：mongo 10.5.XX.XX:端口</li><li>show dbs</li><li>use 某db</li><li>show tables</li><li>db.sometable.find({‘_id’:’XX’});</li><li>db.sometable.update({条件},{$set:{key:value}},{multi:true}));</li></ul><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sometable.find(&#123;&apos;url&apos;:&#123;$regex:/key/i&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="新建表"><a href="#新建表" class="headerlink" title="新建表"></a>新建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(&apos;表名&apos;)</span><br></pre></td></tr></table></figure><h3 id="关闭MongoDB"><a href="#关闭MongoDB" class="headerlink" title="关闭MongoDB"></a>关闭MongoDB</h3><ul><li>先退出：mongo –port 8415（只用端口号登录）</li><li>use admin</li><li>db.shutdownServer()</li></ul><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>cd到MongoDB安装文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f mongod.conf</span><br></pre></td></tr></table></figure><h3 id="复制集"><a href="#复制集" class="headerlink" title="复制集"></a>复制集</h3><p>MongoDB数据库有多个节点时，会包含一个Primary节点和多个Secondary节点，数据先写入Primary节点，其他Secondary再从Primary中同步写入的数据，因此当连接数据库后，光标起始位置会显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某某db:PRIMARY&gt;</span><br></pre></td></tr></table></figure></p><p>或：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某某db:SECONDARY&gt;</span><br></pre></td></tr></table></figure></p><p>当要操作Secondary节点时，由于secondary节点默认不可读，会收到一下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;errmsg&quot; : &quot;not master and slaveOk=false&quot;,</span><br><span class="line">&quot;code&quot; : 13435,</span><br><span class="line">&quot;codeName&quot; : &quot;NotMasterNoSlaveOk&quot;</span><br></pre></td></tr></table></figure></p><p>解决办法，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.slaveOk();</span><br></pre></td></tr></table></figure></p><p>但下次连接是依然报错，若想根治，则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.mongorc.js</span><br><span class="line"></span><br><span class="line">增加:rs.slaveOk();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因业务原因，需登录机器手动操作MongoDB，每次操作每次查，现备份一次，方便日后：&lt;br&gt;
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://chayangge.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>TCP三次握手与SYN Flood攻击</title>
    <link href="http://chayangge.com/2018/09/08/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8ESYN-Flood%E6%94%BB%E5%87%BB/"/>
    <id>http://chayangge.com/2018/09/08/TCP三次握手与SYN-Flood攻击/</id>
    <published>2018-09-08T08:08:07.000Z</published>
    <updated>2018-10-30T02:19:35.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>三次握手大家都耳熟能详了：</p><ul><li>客户端发起握手信号SYN（Synchronize Sequence Numbers），然后进入 SYN_SEND 状态，等待服务端响应</li><li>服务端收到信号，返回SYN+ACK（Synchronization-Acknowledgement）信号，声明做好接收消息的准备，并要求客户端也要做好接收消息的准备，然后进入SYN_RCVD状态，也就是半开状态，服务端会持续等待客户端再次发起的确认信息，这个等待时间很长，能达到分钟级别。（注意：这里是攻击的核心点）</li><li>客户端收到消息后，再次发送ACK(Acknowledgement)消息给服务端，声明做好了接收数据的准备</li><li>连接成功</li></ul><h3 id="为什么三次？"><a href="#为什么三次？" class="headerlink" title="为什么三次？"></a>为什么三次？</h3><p>因为通信双方要互相告知自己的Sequence Numbers，这个序号将作为后续通讯的数字信号，TCP会议这个序号来拼接数据，以保证数据段的顺序。相当于两人如果发生转账，必须要先知到彼此的账号一样。</p><p>其次，三次是满足一个完整、妥善会话的最小逻辑单元，比如：</p><ul><li>A:我账号是001，求汇款500元？</li><li>B:可以，我的账号002，已向你转账500。</li><li>A:好的，收到！</li></ul><p>中间任何一步的失败都会造成会话的不完整，要么A不能确认B是否转账，要么B不能确认A是否收到汇款。</p><h3 id="SYN-Flood攻击"><a href="#SYN-Flood攻击" class="headerlink" title="SYN Flood攻击"></a>SYN Flood攻击</h3><p>如上所述，B转账后会处于半开放状态，要持续等待两分钟，直到收到A的确认收到汇款消息为止。等待是焦急的，劳神的，是耗费脑细胞的。当成千上万的虚假客户端只发送握手信号SYN，收到服务端信号后，并不再次发起确认信号时，服务端则会占用大量的系统内存来维持等待这些半开放的连接，耗尽系统资源，导致正常的握手请求得不到响应，这就是SYN Flood攻击的原理。</p><h3 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h3><ul><li>缩短SYN Timeout时间</li><li>提高半开状态数量</li><li>SYN cookie：<blockquote><p>服务端收到握手信号SYN，在返回SYN+ACK时对ACK进行加密，加密信息包含原地址、端口、目标地址，总之能标识是谁发来的信息，然后不进入半开放状态，直接释放所以状态，这样省去了维持等待所耗费的系统资源，当收到客户端字再次发起的ACK信号时，计算是否为上个SYN+ACK消息的返回，如果是则直接进入连接状态。</p></blockquote></li><li>Firewalls and Proxies：<blockquote><p>用防火墙作为客户端和服务端的中间代理，客户端先与防火墙建立三次握手，只有在握手成功后，防火墙再与服务端建立握手，然后防火墙在中间代理数据传输。此时服务端收到的都是正常握手请求。</p></blockquote></li></ul><p>参考：<a href="https://www.wikiwand.com/en/SYN_flood#" target="_blank" rel="noopener">https://www.wikiwand.com/en/SYN_flood#</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;三次握手大家都耳熟能详了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发起握手信号SYN（Synchronize Sequence Numbers），然后进入 SYN_SEND 状态，等待服务端响应&lt;/li&gt;
&lt;li&gt;服务端收到信号，返回SYN+A
      
    
    </summary>
    
    
      <category term="TCP" scheme="http://chayangge.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Base64</title>
    <link href="http://chayangge.com/2018/08/13/Base64/"/>
    <id>http://chayangge.com/2018/08/13/Base64/</id>
    <published>2018-08-12T16:03:30.000Z</published>
    <updated>2018-08-12T16:46:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，Base64不是加密方式，而是一种数据的编码方式，只是在视觉上起到了‘加密’的功能而已。</p><h3 id="为什么会有Base64？"><a href="#为什么会有Base64？" class="headerlink" title="为什么会有Base64？"></a>为什么会有Base64？</h3><p>Base64加密后的信息理论上会比原信息大三分之一左右，数据变大是不利于传输的，那什么优势让它依然被使用呢？</p><p>答案是因为早期的邮件传输协议SMTP只能传输可打印的ASCII码，那不支持传输的ASCII码只能换一种编码方式，用可传输的ASCII码部分来表示信息。</p><h3 id="用了哪些字符码"><a href="#用了哪些字符码" class="headerlink" title="用了哪些字符码"></a>用了哪些字符码</h3><p>虽然名叫base64，但实际用了65个字符，因为尾部用“=”表示结束，首先从0开始，到51位分别为大小写的字母a-z，52至61为数字0-9，另外加两个字符+/，正好64。<br>所以一个标准的base64编码数据就是大小写混合夹杂数字偶尔出现+/，结尾还会有“=”。</p><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><p>转换规则如下：<br><img src="http://7xprui.com1.z0.glb.clouddn.com/base64.png" alt="转换规则"></p><p>直接看字母的二进制数据，base64把原本的8Bit一组的数据从新按6Bit一组，然后把这新的6位二进制转换成十进制，再从10进制中找到对应的字符，组成了base64的编码。这样，无论什么数据，都能用上述64个字符表达出来，而这64个字符在所有的协议中都能顺利传输。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>base64以增加传输数据变大为代价，换取了传输的兼容性，然后仅仅在肉眼上实现了‘加密’。</p><p>前端接触最多的应用场景是用于表达图片二进制信息，把不是很大的图片用base64标识，直接放在html或css中，省去浏览器再发一个资源请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，Base64不是加密方式，而是一种数据的编码方式，只是在视觉上起到了‘加密’的功能而已。&lt;/p&gt;
&lt;h3 id=&quot;为什么会有Base64？&quot;&gt;&lt;a href=&quot;#为什么会有Base64？&quot; class=&quot;headerlink&quot; title=&quot;为什么会有Base64？&quot;
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>天！居然断更了这么久</title>
    <link href="http://chayangge.com/2018/08/12/%E5%A4%A9%EF%BC%81%E5%B1%85%E7%84%B6%E6%96%AD%E6%9B%B4%E4%BA%86%E8%BF%99%E4%B9%88%E4%B9%85/"/>
    <id>http://chayangge.com/2018/08/12/天！居然断更了这么久/</id>
    <published>2018-08-12T06:31:05.000Z</published>
    <updated>2018-08-11T17:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>天！居然断更了这么久，</p><p>换了份工作，</p><p>把博客落下了，</p><p>适应工作节奏后，</p><p>总感觉时间不够用，</p><p>博客就：拖…</p><p>然后，服务器又到期了，</p><p>要不要买服务器呢？买哪家？</p><p>拖…</p><p>终于又买了服务器，</p><p>换了腾讯云，</p><p>可，备案居然要重新审核，</p><p>拖…</p><p>备案终于过了，</p><p>然而，本地博客跑不起来了，</p><p>还得修，</p><p>拖…</p><p>重装了博客、改了配置、再绑域名、装git、装nginx、nginx.config 等一系列操作，</p><p>终于完成了，</p><p>总耗时接近一年！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;天！居然断更了这么久，&lt;/p&gt;
&lt;p&gt;换了份工作，&lt;/p&gt;
&lt;p&gt;把博客落下了，&lt;/p&gt;
&lt;p&gt;适应工作节奏后，&lt;/p&gt;
&lt;p&gt;总感觉时间不够用，&lt;/p&gt;
&lt;p&gt;博客就：拖…&lt;/p&gt;
&lt;p&gt;然后，服务器又到期了，&lt;/p&gt;
&lt;p&gt;要不要买服务器呢？买哪家？&lt;/p&gt;
&lt;p&gt;拖…
      
    
    </summary>
    
    
  </entry>
  
</feed>
